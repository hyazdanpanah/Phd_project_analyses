---
title: "forestry exposure in the Saguenay Fjord"
author: 
- Hediyeh Yazdanpanah
date: "2025-05-29"
output: 
  html_document:
    code_folding : show
    highlight    : pygments
    theme        : yeti
    toc          : TRUE
    toc_depth    : 4
    toc_float:
      collapsed     : TRUE
      smooth_scroll : TRUE
    df_print     : paged
    fig_caption  : TRUE
---
# Introduction

The Saguenay Fjord is one of the world's southernmost fjords and a critical marine ecosystem supporting diverse wildlife, including the endangered St. Lawrence beluga whale population. The surrounding watersheds, located in Quebec's temperate-boreal forest transition zone, have experienced extensive forestry activities that may influence fjord water quality through soil erosion, sediment transport, and altered hydrology.

This analysis quantifies the potential environmental impact of forestry activities on the Saguenay Fjord through a watershed-based exposure model. The methodology aggregates forestry impacts at the watershed scale, places sources at hydrologically-accurate river mouth locations, and applies temporal weighting based on boreal forest recovery timelines to assess current impact potential from historical disturbances.

```{r setup, include=FALSE}
# Handle package conflicts
if("terra" %in% loadedNamespaces()) {
  try(detach("package:terra", unload = TRUE), silent = TRUE)
}

# Load packages in order
library(sf)
library(dplyr) 
library(raster)
library(gdistance)

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```



```{r catchment}
# ===============================================================================
# STEP 1: LOAD WATERSHED DATA AND DEFINE RIVER MOUTH COORDINATES
# ===============================================================================
target_crs <- "+proj=utm +zone=19 +datum=WGS84 +units=m +no_defs"
# Define study area extent
xmin <- 345000
ymin <- 5325000  
xmax <- 450000
ymax <- 5370000
saguenay_extent <- raster::extent(xmin, xmax, ymin, ymax)  # Explicit raster:: namespace
# Load the corrected watersheds
watersheds <- st_read("corrected_watersheds.gpkg")

# Define river mouth coordinates (where each river enters Saguenay Fjord)
# These are approximate coordinates - It may need to refine based on local knowledge
# Load bathymetry first to identify water areas
bathy <- raster("bathy.tif")
bathy_utm <- projectRaster(bathy, crs = target_crs)
saguenay_extent <- raster::extent(xmin, xmax, ymin, ymax)
bathy_proj <- crop(bathy_utm, saguenay_extent)
bathy_200 <- projectRaster(bathy_proj, crs = target_crs, res = c(200, 200))
bathy_200[bathy_200 > 0] <- 0

# Create water mask
water_mask <- bathy_200
water_mask[water_mask < 0] <- -1  # Water areas
water_mask[water_mask >= 0] <- 0  # Land areas

# Convert water areas to polygons
water_poly <- rasterToPolygons(water_mask, dissolve = TRUE,
                               fun = function(x) x == -1)
water_sf <- st_as_sf(water_poly)

print("Water areas identified")
```

```{r rivier_mouth2}
# ===============================================================================
# REPLACE YOUR find_exact_river_mouths FUNCTION WITH THIS IMPROVED VERSION
# ===============================================================================

find_exact_river_mouths <- function(watersheds, water_areas) {
  
  # ENSURE SAME CRS FIRST
  if (!identical(st_crs(watersheds), st_crs(water_areas))) {
    print("Transforming water areas to match watershed CRS...")
    water_areas <- st_transform(water_areas, st_crs(watersheds))
  }
  
  river_mouths_list <- list()
  
  for (i in 1:nrow(watersheds)) {
    watershed <- watersheds[i, ]
    river_name <- watershed$RIVER_NAME
    
    print(paste("Finding river mouth for:", river_name))
    
    # Make geometries valid to avoid topology errors
    watershed <- st_make_valid(watershed)
    water_areas <- st_make_valid(water_areas)
    
    # Get watershed boundary
    watershed_boundary <- st_boundary(watershed)
    
    # Method 1: Direct intersection
    tryCatch({
      intersection <- st_intersection(watershed_boundary, water_areas)
      
      if (nrow(intersection) > 0) {
        # SUCCESS - Direct intersection found
        if (nrow(intersection) > 1) {
          intersection$length <- st_length(intersection)
          intersection <- intersection[which.max(intersection$length), ]
        }
        
        river_mouth_point <- st_centroid(intersection)
        print(paste("✓ Direct intersection found for", river_name))
        
      } else {
        # Method 2: Buffered approach (NEW)
        print(paste("Trying buffered approach for", river_name))
        
        # Buffer watershed boundary by 200m
        watershed_buffered <- st_buffer(watershed_boundary, 200)
        buffered_intersection <- st_intersection(watershed_buffered, water_areas)
        
        if (nrow(buffered_intersection) > 0) {
          # Find point on original boundary closest to buffered intersection
          intersection_centroid <- st_centroid(buffered_intersection)
          closest_point <- st_nearest_points(watershed_boundary, intersection_centroid)
          river_mouth_point <- st_cast(closest_point, "POINT")[1]
          print(paste("✓ Buffered intersection found for", river_name))
          
        } else {
          # Method 3: Proximity approach (IMPROVED)
          print(paste("Using proximity approach for", river_name))
          
          # Find closest point between watershed boundary and water boundary
          water_boundary <- st_boundary(water_areas)
          closest_points <- st_nearest_points(watershed_boundary, water_boundary)
          river_mouth_point <- st_cast(closest_points, "POINT")[1]
          print(paste("⚠ Proximity estimate for", river_name))
        }
      }
      
      # Move point into water (IMPROVED)
      water_centroid <- st_centroid(water_areas)
      current_coords <- st_coordinates(river_mouth_point)
      water_coords <- st_coordinates(water_centroid)
      
      # Direction vector toward water center
      direction <- water_coords - current_coords
      direction_norm <- direction / sqrt(sum(direction^2)) * 75  # 75m into water
      
      final_coords <- current_coords + direction_norm
      final_point <- st_sfc(st_point(final_coords), crs = st_crs(river_mouth_point))
      
      # Create river mouth with attributes
      river_mouth <- st_sf(
        RIVER_NAME = river_name,
        geometry = final_point
      )
      
      river_mouths_list[[i]] <- river_mouth
      print(paste("✓ Completed", river_name))
      
    }, error = function(e) {
      print(paste("ERROR processing", river_name, ":", e$message))
      
      # FALLBACK: Use watershed centroid moved toward water
      watershed_centroid <- st_centroid(watershed)
      water_centroid <- st_centroid(water_areas)
      
      # Move centroid toward water
      centroid_coords <- st_coordinates(watershed_centroid)
      water_coords <- st_coordinates(water_centroid)
      direction <- (water_coords - centroid_coords) * 0.8  # 80% toward water
      
      final_coords <- centroid_coords + direction
      final_point <- st_sfc(st_point(final_coords), crs = st_crs(watershed_centroid))
      
      river_mouth <- st_sf(
        RIVER_NAME = river_name,
        geometry = final_point
      )
      
      river_mouths_list[[i]] <- river_mouth
      print(paste("⚠ Fallback used for", river_name))
    })
  }
  
  # Combine all river mouths
  do.call(rbind, river_mouths_list)
}

# ===============================================================================
# ADD THIS DIAGNOSTIC FUNCTION FOR CHECKING SPECIFIC RIVERS
# ===============================================================================

check_specific_river <- function(river_name, watersheds, water_areas) {
  
  print(paste("=== CHECKING:", river_name, "==="))
  
  # Check if river exists
  if (!river_name %in% watersheds$RIVER_NAME) {
    print("Available rivers:")
    print(unique(watersheds$RIVER_NAME))
    return(NULL)
  }
  
  watershed <- watersheds[watersheds$RIVER_NAME == river_name, ]
  watershed_boundary <- st_boundary(watershed)
  
  # Test intersection
  intersection <- st_intersection(watershed_boundary, water_areas)
  print(paste("Direct intersection results:", nrow(intersection), "features"))
  
  # Test buffered intersection
  watershed_buffered <- st_buffer(watershed_boundary, 200)
  buffered_intersection <- st_intersection(watershed_buffered, water_areas)
  print(paste("Buffered intersection results:", nrow(buffered_intersection), "features"))
  
  # Create diagnostic plot
  bbox <- st_bbox(watershed)
  plot(st_geometry(water_areas), col = "lightblue", border = "blue",
       main = paste("Diagnosis:", river_name),
       xlim = c(bbox[1], bbox[3]), ylim = c(bbox[2], bbox[4]))
  
  plot(st_geometry(watershed), add = TRUE, col = adjustcolor("red", 0.3), border = "red", lwd = 2)
  plot(st_geometry(watershed_boundary), add = TRUE, col = "darkred", lwd = 3)
  
  if (nrow(intersection) > 0) {
    points(st_coordinates(st_centroid(intersection)), pch = 21, bg = "green", cex = 2)
  }
  
  if (nrow(buffered_intersection) > 0) {
    points(st_coordinates(st_centroid(buffered_intersection)), pch = 21, bg = "orange", cex = 2)
  }
}


# Use this function to get exact river mouths
print("Finding exact river mouth locations...")
tryCatch({
  river_mouths_sf <- find_exact_river_mouths(watersheds, water_sf)
}, error = function(e) {
  print(paste("Error in automatic detection:", e$message))
  stop("Cannot proceed without river mouths")
})

print("Exact river mouth coordinates:")
print(river_mouths_sf)

# Use this function to get exact river mouths
print("Finding exact river mouth locations...")
tryCatch({
  river_mouths_sf <- find_exact_river_mouths(watersheds, water_sf)
}, error = function(e) {
  print(paste("Error in automatic detection:", e$message))
  stop("Cannot proceed without river mouths")
})

# FIX CRS MISMATCH - Transform river mouths to target UTM CRS
print("Original CRS of river_mouths_sf:")
print(st_crs(river_mouths_sf))

print("Transforming river mouths to target UTM CRS...")
river_mouths_sf <- st_transform(river_mouths_sf, crs = target_crs)

print("Transformed river mouth coordinates:")
print(river_mouths_sf)

# Verify all points are in water (now both have same CRS)
water_check <- st_intersection(river_mouths_sf, water_sf)
print(paste("River mouths confirmed in water:", nrow(water_check), "out of", nrow(river_mouths_sf)))

# Verify all points are in water
water_check <- st_intersection(river_mouths_sf, water_sf)
print(paste("River mouths confirmed in water:", nrow(water_check), "out of", nrow(river_mouths_sf)))

# Function to project points to nearest water location (if needed)
project_to_water <- function(points, water_areas) {
  water_points_in_water <- list()
  
  for (i in 1:nrow(points)) {
    point <- points[i, ]
    
    # Check if point is already in water
    intersection <- st_intersection(point, water_areas)
    
    if (nrow(intersection) > 0) {
      # Point is already in water
      water_points_in_water[[i]] <- point
      print(paste(point$RIVER_NAME, "- already in water"))
    } else {
      # Project to nearest water edge
      nearest_water <- st_nearest_feature(point, water_areas)
      
      # Get boundary of water area
      water_boundary <- st_boundary(water_areas[nearest_water, ])
      
      # Find closest point on water boundary
      closest_point <- st_nearest_points(point, water_boundary)
      closest_point_end <- st_cast(closest_point, "POINT")[2]
      
      # Move slightly inside water (100m buffer)
      water_centroid <- st_centroid(water_areas[nearest_water, ])
      direction <- st_coordinates(water_centroid) - st_coordinates(closest_point_end)
      direction_norm <- direction / sqrt(sum(direction^2)) * 100  # 100m into water
      
      new_coords <- st_coordinates(closest_point_end) + direction_norm
      new_point <- st_sfc(st_point(new_coords), crs = st_crs(point))
      
      # Create new point with attributes
      water_point <- st_sf(
        RIVER_NAME = point$RIVER_NAME,
        geometry = new_point
      )
      
      water_points_in_water[[i]] <- water_point
      print(paste(point$RIVER_NAME, "- moved to water"))
    }
  }
  
  # Combine all points
  do.call(rbind, water_points_in_water)
}

# If any points are not in water, move them
if (nrow(water_check) < nrow(river_mouths_sf)) {
  print("Moving remaining points to water...")
  river_mouths_sf <- project_to_water(river_mouths_sf, water_sf)
}
```


```{r water_mouth_plot}


# ===============================================================================
# DIAGNOSTIC PLOT: VISUALIZE RIVER MOUTH LOCATIONS
# ===============================================================================

# Create a comprehensive plot showing river mouths and watersheds
library(RColorBrewer)

# Set up colors for each river
n_rivers <- nrow(river_mouths_sf)
river_colors <- rainbow(n_rivers, alpha = 0.7)
names(river_colors) <- river_mouths_sf$RIVER_NAME

print("Creating diagnostic plot of river mouth locations...")

# Create the main plot
plot(st_geometry(water_sf), 
     col = "lightblue", 
     border = "blue",
     main = "Automatic River Mouth Detection Results",
     xlab = "Easting (UTM Zone 19N)", 
     ylab = "Northing (UTM Zone 19N)",
     xlim = c(xmin, xmax),
     ylim = c(ymin, ymax))

# Add watersheds with different colors
plot(st_geometry(watersheds), 
     add = TRUE, 
     col = adjustcolor(river_colors[watersheds$RIVER_NAME], alpha = 0.3),
     border = river_colors[watersheds$RIVER_NAME], 
     lwd = 1.5)

# Add river mouth points
points(st_coordinates(river_mouths_sf)[,1], 
       st_coordinates(river_mouths_sf)[,2],
       pch = 21, 
       cex = 2, 
       bg = river_colors[river_mouths_sf$RIVER_NAME],
       col = "black",
       lwd = 2)

# Add river mouth labels
text(st_coordinates(river_mouths_sf)[,1], 
     st_coordinates(river_mouths_sf)[,2],
     labels = river_mouths_sf$RIVER_NAME,
     pos = 3,  # Above the points
     cex = 0.7,
     col = "black",
     font = 2)  # Bold

# Add legend
legend("topright", 
       legend = c("Water Areas", "Watersheds", "River Mouths"),
       fill = c("lightblue", "gray", NA),
       pch = c(NA, NA, 21),
       pt.bg = c(NA, NA, "red"),
       pt.cex = c(NA, NA, 1.5),
       cex = 0.8,
       bg = "white")

# Add coordinates for verification
print("Final River Mouth Coordinates (UTM):")
coords_df <- data.frame(
  River = river_mouths_sf$RIVER_NAME,
  Easting = round(st_coordinates(river_mouths_sf)[,1], 0),
  Northing = round(st_coordinates(river_mouths_sf)[,2], 0)
)
print(coords_df)

# Summary statistics
print("Summary:")
print(paste("Total watersheds:", nrow(watersheds)))
print(paste("Total river mouths detected:", nrow(river_mouths_sf)))
print(paste("River mouths in water:", nrow(water_check)))
print(paste("Study area extent: X =", xmin, "to", xmax, ", Y =", ymin, "to", ymax))

# Check if all river mouths are within study area
within_bounds <- st_coordinates(river_mouths_sf)[,1] >= xmin & 
                st_coordinates(river_mouths_sf)[,1] <= xmax &
                st_coordinates(river_mouths_sf)[,2] >= ymin & 
                st_coordinates(river_mouths_sf)[,2] <= ymax

print(paste("River mouths within study bounds:", sum(within_bounds), "out of", length(within_bounds)))

```
# logging 

## loading data 
The <a href="https://www.donneesquebec.ca/recherche/dataset/recolte-et-reboisement">Harvest and Other Silvicultural Interventions</a> dataset is part of Québec's ecoforestry inventory program. It provides up-to-date information on forest management activities—such as harvesting, thinning, and reforestation—conducted on public and private forest lands across southern Québec. It is produced by various stakeholders, including the Québec Ministry of Natural Resources and Forests and private forest agencies. Only interventions covering areas of 0.1 hectares or more are mapped. It is a huge data set so before I load data , check the dataset:

```{r forestry_data}
# ===============================================================================
# STEP 2: LOAD AND PROCESS FORESTRY DATA BY WATERSHED
# ===============================================================================

# Load forestry data (using same approach as before)
forestry_data <- st_read("INTERV_FORES_PROV.gpkg",
                         query = "SELECT exercice, superficie, geom
                                FROM (
                                 SELECT exercice, superficie, geom,
                                 ROW_NUMBER() OVER (PARTITION BY exercice ORDER BY RANDOM()) as rn
                                 FROM 'INTERV_FORES_PROV' 
                                  WHERE exercice >= 1980
                               )
                                WHERE rn <= 1000")

# Transform to UTM
forestry_utm <- st_transform(forestry_data, crs = target_crs)

# Transform both to the same UTM CRS
watersheds <- st_transform(watersheds, crs = target_crs)
forestry_utm <- st_transform(forestry_data, crs = target_crs)
```

```{r total nitrogen impact}
# ===============================================================================
# FORESTRY INTENSITY INDEX USING TABLE 3 CUMULATIVE APPROACH
# ===============================================================================

get_forestry_intensity_index <- function(years_since, proportion_logged_percent) {
  # Table 3 parameter estimates for Total N (using all 10 years)
  # aj (slope coefficient)  
  aj <- 1.01
  
  # All annual specific concentration parameters (b1 to b10 for years 1-10)
  # Using original values from Table 3, including non-significant ones
  table3_coefficients <- c(
    154.64,   # b1 - Year 1
    205.48,   # b2 - Year 2 
    460.75,   # b3 - Year 3 (peak)
    377.40,   # b4 - Year 4
    465.08,   # b5 - Year 5 (peak)
    162.96,   # b6 - Year 6
    128.99,   # b7 - Year 7
    47.44,    # b8 - Year 8
    -32.85,   # b9 - Year 9 (negative - recovery)
    -51.25    # b10 - Year 10 (negative - recovery)
  )
  
  # Return 0 for invalid inputs
  if (is.na(years_since) || years_since <= 0 || is.na(proportion_logged_percent) || proportion_logged_percent <= 0) {
    return(0)
  }
  
  # Cap at 100% and convert to decimal
  if (proportion_logged_percent > 100) proportion_logged_percent <- 100
  proportion_decimal <- proportion_logged_percent / 100
  
  # CUMULATIVE APPROACH: Sum impacts from all years since logging
  # Formula: Aj + b1×%logged + b2×%logged + ... + bk×%logged (where k = years_since)
  
  cumulative_impact <- aj  # Start with baseline
  
  # Add impact for each year that has passed since logging
  years_to_include <- min(round(years_since), 10)  # Cap at 10 years max
  
  for (year in 1:years_to_include) {
    cumulative_impact <- cumulative_impact + (table3_coefficients[year] * proportion_decimal)
  }
  
  return(cumulative_impact)
}

# Enhanced version with averaging and calibration
get_forestry_intensity_index_calibrated <- function(years_since, proportion_logged_percent) {
  # Enhanced coefficients using confidence interval midpoints or smoothed values
  # (You could modify these based on additional statistical analysis)
  aj <- 1.01
  
  # Option 1: Use original coefficients
  coefficients_original <- c(154.64, 205.48, 460.75, 377.40, 465.08, 162.96, 128.99, 47.44, -32.85, -51.25)
  # Choose which coefficients to use (change this as needed)
  table3_coefficients <- coefficients_original  
  
  # Input validation
  if (is.na(years_since) || years_since <= 0 || is.na(proportion_logged_percent) || proportion_logged_percent <= 0) {
    return(0)
  }
  
  # Cap and convert
  if (proportion_logged_percent > 100) proportion_logged_percent <- 100
  proportion_decimal <- proportion_logged_percent / 100
  
  # Calculate cumulative impact
  cumulative_impact <- aj
  years_to_include <- min(round(years_since), 10)
  
  for (year in 1:years_to_include) {
    cumulative_impact <- cumulative_impact + (table3_coefficients[year] * proportion_decimal)
  }
  # CALIBRATION: Normalize to create index (0-1)
  
  #  Use 500 µg/L as suggested, or 465.08 from Table 3
  max_calibration_value <- 500  # or use max_theoretical_impact, or 465.08
  
  # Calculate normalized index
  forestry_intensity_index <- cumulative_impact / max_calibration_value
  
  # Ensure index is between 0 and 1
  forestry_intensity_index <- max(0, min(1, forestry_intensity_index))
  
  return(list(
    raw_impact = cumulative_impact,
    intensity_index = forestry_intensity_index,
    max_calibration = max_calibration_value
  ))
}

# Function to calculate forestry intensity for multiple logging events
calculate_watershed_forestry_intensity <- function(logging_years, logging_proportions, current_year = 2024) {
  # For watersheds with multiple logging events
  # logging_years: vector of years when logging occurred
  # logging_proportions: vector of % logged for each event
  
  total_intensity <- 0
  
  for (i in 1:length(logging_years)) {
    years_since <- current_year - logging_years[i]
    if (years_since > 0 && years_since <= 10) {  # Only include recent logging
      event_intensity <- get_forestry_intensity_index(years_since, logging_proportions[i])
      total_intensity <- total_intensity + event_intensity
    }
  }
  
  # Normalize total intensity
  max_calibration <- 500
  intensity_index <- min(1, total_intensity / max_calibration)
  
  return(list(
    total_raw_intensity = total_intensity,
    intensity_index = intensity_index
  ))
}

```

```{r extraxt_data}
# ===============================================================================
# UPDATED PROCESS_WATERSHED_FORESTRY FUNCTION USING CUMULATIVE APPROACH
# ===============================================================================
process_watershed_forestry <- function(watershed_name) {
  # Get the specific watershed
  watershed <- watersheds[watersheds$RIVER_NAME == watershed_name, ]
  
  if (nrow(watershed) == 0) {
    warning(paste("No watershed found for", watershed_name))
    return(NULL)
  }
  
  # Calculate watershed area
  watershed_area_ha <- as.numeric(st_area(watershed)) / 10000
  
  # Ensure CRS match before intersection
  if (!identical(st_crs(forestry_utm), st_crs(watershed))) {
    watershed <- st_transform(watershed, st_crs(forestry_utm))
  }
  
  # Crop forestry data to this watershed
  tryCatch({
    watershed <- st_make_valid(watershed)
    forestry_utm_valid <- st_make_valid(forestry_utm)
    
    watershed_forestry <- st_intersection(forestry_utm_valid, watershed)
  }, error = function(e) {
    warning(paste("Error intersecting", watershed_name, ":", e$message))
    return(data.frame(
      RIVER_NAME = watershed_name,
      total_forestry_intensity = 0,
      forestry_intensity_index = 0,
      count_interventions = 0,
      total_logged_area = 0,
      proportion_logged = 0,
      watershed_area_ha = watershed_area_ha
    ))
  })
  
  if (nrow(watershed_forestry) == 0) {
    return(data.frame(
      RIVER_NAME = watershed_name,
      total_forestry_intensity = 0,
      forestry_intensity_index = 0,
      count_interventions = 0,
      total_logged_area = 0,
      proportion_logged = 0,
      watershed_area_ha = watershed_area_ha
    ))
  }
  
  # Calculate forestry impacts using CUMULATIVE Table 3 methodology
  watershed_forestry <- watershed_forestry %>%
    mutate(
      exercice_num = as.numeric(exercice),
      years_since = 2024 - exercice_num,
      # Calculate intersection area (actual logged area within watershed)
      intersection_area = as.numeric(st_area(.)) / 10000
    )
  
  # Group by logging year to calculate cumulative impacts
  yearly_impacts <- watershed_forestry %>%
    st_drop_geometry() %>%
    group_by(years_since) %>%
    summarise(
      yearly_logged_area = sum(intersection_area, na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    mutate(
      yearly_proportion = (yearly_logged_area / watershed_area_ha) * 100,
      # Use the new cumulative forestry intensity function
      cumulative_intensity = mapply(get_forestry_intensity_index, years_since, yearly_proportion),
      # Weight by actual logged area for this year
      weighted_intensity = cumulative_intensity * (yearly_logged_area / watershed_area_ha)
    )
  
  # Calculate overall watershed forestry intensity
  # Method 1: Sum weighted intensities from all logging years
  total_weighted_intensity <- sum(yearly_impacts$weighted_intensity, na.rm = TRUE)
  
  # Method 2: Calculate using total proportion and weighted average years
  total_proportion <- (sum(yearly_impacts$yearly_logged_area, na.rm = TRUE) / watershed_area_ha) * 100
  
  # Calculate area-weighted average years since logging
  if (sum(yearly_impacts$yearly_logged_area, na.rm = TRUE) > 0) {
    weighted_avg_years <- sum(yearly_impacts$years_since * yearly_impacts$yearly_logged_area, na.rm = TRUE) / 
                         sum(yearly_impacts$yearly_logged_area, na.rm = TRUE)
  } else {
    weighted_avg_years <- 0
  }
  
  # Alternative calculation using weighted average
  if (total_proportion > 0 && weighted_avg_years > 0) {
    alternative_intensity <- get_forestry_intensity_index(weighted_avg_years, total_proportion)
  } else {
    alternative_intensity <- 0
  }
  
  # Use the higher of the two methods (more conservative approach)
  final_intensity <- max(total_weighted_intensity, alternative_intensity, na.rm = TRUE)
  
  # Calculate normalized intensity index (0-1)
  max_calibration <- 500  # As suggested by supervisor
  intensity_index <- min(1, max(0, final_intensity / max_calibration))
  
  # Aggregate watershed summary
  watershed_summary <- data.frame(
    RIVER_NAME = watershed_name,
    total_forestry_intensity = final_intensity,
    forestry_intensity_index = intensity_index,
    count_interventions = nrow(watershed_forestry),
    total_logged_area = sum(yearly_impacts$yearly_logged_area, na.rm = TRUE),
    proportion_logged = total_proportion,
    weighted_avg_years_since = weighted_avg_years,
    watershed_area_ha = watershed_area_ha,
    # Additional details for analysis
    max_single_year_impact = max(yearly_impacts$cumulative_intensity, na.rm = TRUE),
    years_with_logging = nrow(yearly_impacts)
  )
  
  return(watershed_summary)
}

```
# Logging impact
Logging activities create significant problems related to erosion, sedimentation and altered stream flow patterns, with areas that have been logged being far more likely to suffer from major landslides and erosion events which deposit abnormally high levels of sediment into area streams. Recovery processes can last for decades, with some forest disturbances requiring 20 years or more for full resilience recovery (Gao et al., 2024).
To account for these temporal dynamics, we applied a temporal decay function that weights recent interventions more heavily than older ones, reflecting the diminishing current impact of historical disturbances.
Recovery processes can last for decades, with some forest disturbances requiring 20 years or more for full resilience recovery (Gao et al., 2024). To account for these temporal dynamics, we applied a temporal decay function that weights recent interventions more heavily than older ones, reflecting the diminishing current impact of historical disturbances.

**Soil and Water Quality Impacts**
Among the studies reviewed for boreal forests, dissolved organic carbon (DOC) exports usually increased after logging, and nitrogen (N) mineralization and nitrification often increased with resulting increased N availability and exports to receiving waters. Similar processes and responses occurred for phosphorus (P), but to a lesser extent than for N. In most cases, base cations were released and exported to receiving waters after logging (Kreutzweiser et al., 2008).
Forestry operations have been shown to increase mercury and methyl mercury output from boreal catchments. Clearcutting and (or) site preparation significantly increases the mobility of total mercury and methyl mercury accumulated in forest soil and may be an important factor for the total input of mercury to boreal freshwater ecosystems (Porvari et al., 2003; Garcia et al., 2007).

**Quebec-Specific Research**
A study documenting forest recovery following a 1941 fire on a boreal floodplain along a third-order stream in northern Quebec found that because of low establishment rate and slow growth of postfire conifers, forest recovery towards prefire tree density is unlikely under present-day conditions (Bouchon & Arseneault, 2004). This demonstrates the extended recovery periods characteristic of Quebec's boreal forests.
Research conducted in Quebec's Montmorency Forest found that summer stream water quality was monitored before and following the logging of 50% of the boreal forest within small watersheds, with logging conducted in winter on snow cover according to recommended best management practices to minimize soil disturbance. However, despite best practices, water quality impacts still occurred.

# Economic and Ecological Costs
Soil erosion from forestry activities has significant economic implications, with accelerated soil erosion inflicting extreme changes in terrestrial and aquatic ecosystems at an annual average cost of USD 44 billion (Pimentel et al., 1995; Nouri et al., 2024). The deposition of fine sediment on stream beds degrades spawning areas, reduces pool refuge habitat, decreases winter refuge areas for juveniles, and impedes feeding visibility (Sierra Forest Legacy, 2024).
Recent analysis found that clearcutting is responsible for an estimated 26 million metric tons of carbon dioxide emissions annually in Canada—an amount equivalent to the annual emissions of 5.5 million vehicles (Axelrod, 2023). A single year's worth of clearcutting across Quebec equaled 62 percent of the annual emission reductions that Quebec has promised to make by 2020.

## Forestry Nitrogen Impact Assessment

The forestry impact assessment was developed to quantify nitrogen loading potential from historical forest interventions to the Saguenay Fjord. This approach utilizes empirical data from paired catchment studies in Fennoscandian boreal forests to estimate realistic nutrient export impacts based on watershed-scale logging patterns.

### Empirical Temporal Framework

This analysis applies specific concentration values derived from **Palviainen et al. (2015)**, who combined water quality data from eight boreal headwater catchment pairs in Finland and Sweden. Their research provides quantitative estimates of excess nitrogen export (kg ha⁻¹ year⁻¹) following clear-cutting operations under different conditions:

* **Years 1-2:** Initial impact period with moderate nitrogen mobilization
* **Years 3-5:** Peak impact period with maximum nitrogen export to receiving waters  
* **Year 6+:** Return to baseline conditions as forest recovery stabilizes nutrient cycling

The Palviainen et al. (2015) study found that nitrogen concentrations increased significantly during the second through fifth years after clear-cutting, with impacts disappearing within 6 years. This empirical timeline reflects the specific recovery dynamics of boreal forest ecosystems under Nordic conditions similar to Quebec's boreal forests.

### Proportion-Dependent Impact Scaling

The Finnish research demonstrates that nitrogen export scales **non-linearly** with the proportion of watershed area harvested.It shows that impacts increase exponentially rather than linearly with logging intensity:



## Watershed-Scale Nitrogen Impact Calculation

The nitrogen impact assessment employs a watershed aggregation methodology that processes forestry data at the hydrologically-relevant scale rather than treating individual logging polygons in isolation.

### Calculation Framework



### Final Formula


This approach ensures that:

* **Watershed context determines impact intensity:** The same logging area produces different nitrogen export depending on watershed size
* **Empirical relationships guide estimates:** Impact values are based on measured nutrient export data rather than theoretical weights
* **Hydrological realism is maintained:** Impacts are aggregated at the watershed scale and discharged at river mouth locations
* **Temporal accuracy reflects boreal conditions:** The 5-year impact window matches observed recovery patterns in northern forests

### Quality Control and Validation

The empirical lookup function includes interpolation for intermediate values and extrapolation for proportions below 20%. Areas with no logging activity or logging older than 5 years receive zero current impact scores, reflecting the documented return to baseline nutrient export conditions.

### Scientific Justification for Saguenay Fjord

This methodology produces nitrogen loading estimates that:

* **Utilize peer-reviewed empirical data** from boreal forest conditions analogous to Quebec
* **Account for watershed-scale hydrological processes** that control nutrient transport and retention
* **Provide quantitative nitrogen export estimates** comparable to water quality standards and regulatory thresholds
* **Reflect proportion-dependent threshold effects** documented in catchment-scale forestry research
* **Apply appropriate temporal dynamics** specific to boreal forest recovery processes

The resulting nitrogen loading estimates (kg N year⁻¹) serve as the intensity values for calculating exposure gradients from forestry sources to fjord waters, enabling quantitative assessment of terrestrial nutrient loading impacts on the Saguenay marine ecosystem based on established boreal forest biogeochemistry research.

```{r river_source}
# ===============================================================================
# CREATE RIVER MOUTH SOURCES WITH FORESTRY INTENSITY 
# ===============================================================================

# Process all watersheds with improved methodology
watershed_forestry_summary <- data.frame()
for (river_name in unique(watersheds$RIVER_NAME)) {
  summary <- process_watershed_forestry(river_name)
  if (!is.null(summary)) {
    watershed_forestry_summary <- rbind(watershed_forestry_summary, summary)
  }
}

print("Watershed processing complete. Summary:")
print(head(watershed_forestry_summary))

# Merge with river mouths
river_mouth_sources <- merge(river_mouths_sf, watershed_forestry_summary,
                            by = "RIVER_NAME", all.x = TRUE)

# Handle watersheds with no forestry data - USE CORRECT COLUMN NAMES
river_mouth_sources$total_forestry_intensity[is.na(river_mouth_sources$total_forestry_intensity)] <- 0
river_mouth_sources$forestry_intensity_index[is.na(river_mouth_sources$forestry_intensity_index)] <- 0

# Filter out rivers with zero impact - USING INTENSITY INDEX
river_mouth_sources_active <- river_mouth_sources[river_mouth_sources$forestry_intensity_index > 0, ]

# Option 1: Use the normalized intensity index (0-1) for exposure calculation
names(river_mouth_sources_active)[names(river_mouth_sources_active) == "forestry_intensity_index"] <- "intensity_index"

print("Forestry intensity summary by watershed:")
print(st_drop_geometry(river_mouth_sources_active[, c("RIVER_NAME", "intensity_index", 
                                                      "proportion_logged", "watershed_area_ha",
                                                      "weighted_avg_years_since", "years_with_logging")]))

# Additional summary statistics
print("\n=== FORESTRY INTENSITY STATISTICS ===")
print(paste("Total watersheds processed:", nrow(watershed_forestry_summary)))
print(paste("Watersheds with forestry activity:", nrow(river_mouth_sources_active)))
print(paste("Mean intensity index:", round(mean(river_mouth_sources_active$intensity_index, na.rm = TRUE), 3)))
print(paste("Max intensity index:", round(max(river_mouth_sources_active$intensity_index, na.rm = TRUE), 3)))
print(paste("Range of proportion logged:", 
            round(min(river_mouth_sources_active$proportion_logged, na.rm = TRUE), 1), "-", 
            round(max(river_mouth_sources_active$proportion_logged, na.rm = TRUE), 1), "%"))

# Display top watersheds by intensity
top_watersheds <- river_mouth_sources_active[order(-river_mouth_sources_active$intensity_index)[1:min(5, nrow(river_mouth_sources_active))], ]
print("\nTop 5 watersheds by forestry intensity:")
print(st_drop_geometry(top_watersheds[, c("RIVER_NAME", "intensity_index", "proportion_logged", "weighted_avg_years_since")]))
```

```{r step5}
# ===============================================================================
# STEP 5: SETUP BATHYMETRY AND TRANSITION LAYER 
# ===============================================================================

# Finish bathymetry processing (already started above)
bathy_200[bathy_200 > 0] <- 0  # Ensure land areas are 0

# Transition function and layer
fun_bathy <- function(x) {
  ifelse(x[1] > x[2],
         pmax(0.001, 1 - abs((x[2] - x[1]) / x[2])),
         0.45)
}

tr_bathy <- transition(bathy_200,
                       transitionFunction = fun_bathy,
                       directions = 8,
                       symm = FALSE) %>%
  geoCorrection(., type = "c")

print("Transition layer created")

# Create grid
bbox_utm <- list(rbind(c(xmin, ymin), c(xmax, ymin), c(xmax, ymax),
                       c(xmin, ymax), c(xmin, ymin))) %>%
  st_polygon() %>%
  st_sfc(., crs = target_crs)

grid_res <- 200
grid_points <- st_make_grid(bbox_utm, cellsize = grid_res, what = "centers") %>%
  st_geometry()
grid_polygons <- st_make_grid(bbox_utm, cellsize = grid_res, what = "polygons") %>%
  st_geometry()

grid_points_sf <- st_sf(geometry = grid_points)
grid_polygons_sf <- st_sf(geometry = grid_polygons)

print(paste("Grid points created:", nrow(grid_points_sf)))

# ===============================================================================
```

```{r step6 not use please}
# STEP 6: LOAD RelativeExposure FUNCTION 
# ===============================================================================

RelativeExposure <- function(source, transition, decay_type, grid_points_sf,
                             grid_polygons_sf, empty_raster) {
  
  if (!identical(st_crs(source), st_crs(grid_points_sf))) {
    stop("CRS mismatch between source and grid points")
  }
  
  tryCatch({
    source_coords <- st_coordinates(source)
    source_sp <- SpatialPoints(coords = source_coords,
                               proj4string = CRS(st_crs(source)$proj4string))
    
    grid_points_sp <- as(grid_points_sf, "Spatial")
    
    print(paste("Calculating distances from", nrow(source_sp), "river mouth sources to",
                nrow(grid_points_sp), "grid points..."))
    
    distance <- costDistance(transition, grid_points_sp, source_sp)
    
    if (all(is.na(distance))) {
      stop("All distance values are NA")
    }
    
    if (ncol(distance) == 1) {
      min_dist <- distance[, 1]
    } else {
      min_dist <- apply(distance, 1, min, na.rm = TRUE)
    }
    
    a_param <- switch(decay_type,
                      "I"   = -1,
                      "II"  = -0.1,
                      "III" = -0.01,
                      "IV"  = -0.001,
                      stop("Invalid decay type"))
    
    exposure <- exp(a_param * min_dist)
    
    coords <- st_coordinates(grid_points_sf)
    sp_exposure <- SpatialPointsDataFrame(
      coords = coords,
      data = data.frame(exposure = exposure),
      proj4string = CRS(st_crs(empty_raster)$proj4string)
    )
    
    exposure_rast <- rasterize(sp_exposure, empty_raster,
                               field = "exposure", fun = mean, background = NA)
    
    max_value <- cellStats(exposure_rast, stat = "max", na.rm = TRUE)
    if (!is.na(max_value) && max_value > 0) {
      exposure_rast[] <- exposure_rast[] / max_value
    }
    
    return(exposure_rast)
    
  }, error = function(e) {
    stop("Error in exposure calculation: ", e$message)
  })
}
```

# with Gaussian kernel function 
```{r Gaussian Kernel}
RelativeExposure <- function(source, transition, decay_type, grid_points_sf,
                             grid_polygons_sf, empty_raster) {
  
  if (!identical(st_crs(source), st_crs(grid_points_sf))) {
    stop("CRS mismatch between source and grid points")
  }
  
  tryCatch({
    source_coords <- st_coordinates(source)
    source_sp <- SpatialPoints(coords = source_coords,
                               proj4string = CRS(st_crs(source)$proj4string))
    
    grid_points_sp <- as(grid_points_sf, "Spatial")
    
    print(paste("Calculating distances from", nrow(source_sp), "river mouth sources to",
                nrow(grid_points_sp), "grid points..."))
    
    distance <- costDistance(transition, grid_points_sp, source_sp)
    
    if (all(is.na(distance))) {
      stop("All distance values are NA")
    }
    
    if (ncol(distance) == 1) {
      min_dist <- distance[, 1]
    } else {
      min_dist <- apply(distance, 1, min, na.rm = TRUE)
    }
    
    # SAME decay coefficients as before
    a_param <- switch(decay_type,
                      "I"   = -1,
                      "II"  = -0.1,
                      "III" = -0.01,
                      "IV"  = -0.001,
                      stop("Invalid decay type"))
    
    # Elliot's Gaussian kernel with scaling factor 0.000025
    exposure <- exp((0.000025 * a_param) * (min_dist)^2)
    
    coords <- st_coordinates(grid_points_sf)
    sp_exposure <- SpatialPointsDataFrame(
      coords = coords,
      data = data.frame(exposure = exposure),
      proj4string = CRS(st_crs(empty_raster)$proj4string)
    )
    
    exposure_rast <- rasterize(sp_exposure, empty_raster,
                               field = "exposure", fun = mean, background = NA)
    
    max_value <- cellStats(exposure_rast, stat = "max", na.rm = TRUE)
    if (!is.na(max_value) && max_value > 0) {
      exposure_rast[] <- exposure_rast[] / max_value
    }
    
    return(exposure_rast)
    
  }, error = function(e) {
    stop("Error in exposure calculation: ", e$message)
  })
}
```


# Calculate forestry exposure

This methodology produces an intensity index that:
* Prioritizes recent, large-scale interventions that likely have the strongest current impact on fjord water quality

* Appropriately weights historical interventions based on recovery time

* Maintains spatial representativeness while focusing computational resources on relevant impacts

* Provides a standardized metric comparable across different intervention types and time periods

The resulting intensity index serves as the basis for calculating exposure gradients from forestry sources to fjord waters, enabling quantitative assessment of terrestrial forest management impacts on marine ecosystems.

```{r forestry_exposure}
# ===============================================================================
# STEP 7: CALCULATE IMPROVED FORESTRY EXPOSURE WITH INTENSITY WEIGHTING
# ===============================================================================

template_raster <- raster(raster::extent(bathy_200), resolution = 200,
                         crs = projection(bathy_200))
decay_type <- "III"
gc()

print("Starting improved forestry exposure calculation from river mouths...")
print(paste("Processing", nrow(river_mouth_sources_active), "river mouth sources..."))

# Calculate exposure for each river mouth separately and weight by intensity
river_exposures <- list()

for(i in 1:nrow(river_mouth_sources_active)) {
  river_name <- river_mouth_sources_active$RIVER_NAME[i]
  intensity <- river_mouth_sources_active$intensity_index[i]
  
  print(paste("Processing", river_name, "- Intensity:", round(intensity, 4)))
  
  # Calculate exposure for this single river mouth
  single_exposure <- RelativeExposure(
    source = river_mouth_sources_active[i,],
    transition = tr_bathy,
    decay_type = decay_type,
    grid_points_sf = grid_points_sf,
    grid_polygons_sf = grid_polygons_sf,
    empty_raster = template_raster
  )
  
  # Weight by intensity index
  river_exposures[[i]] <- single_exposure * intensity
  
  print(paste("Completed", river_name))
}

# Combine all weighted exposures
print("Combining all weighted river exposures...")
forestry_exp_improved <- Reduce('+', river_exposures)

# Normalize to 0-1 scale
max_value <- cellStats(forestry_exp_improved, stat = "max", na.rm = TRUE)
forestry_exp_improved <- forestry_exp_improved / max_value

print("Improved forestry exposure calculation complete!")

# Apply water mask
forestry_exp_improved <- mask(forestry_exp_improved, water_mask < 0)
forestry_exp_improved[forestry_exp_improved == 0] <- NA

# Save results
save(forestry_exp_improved, river_mouth_sources_active, watershed_forestry_summary,
     file = "improved_forestry_exp.RData")

# Print summary statistics
print("\n=== FINAL EXPOSURE STATISTICS ===")
print(paste("Max exposure value:", round(max_value, 6)))
print(paste("Mean exposure:", round(cellStats(forestry_exp_improved, "mean", na.rm=TRUE), 6)))
print(paste("Non-NA cells:", sum(!is.na(values(forestry_exp_improved)))))
```

```{r plot}
# ===============================================================================
# STEP 8: PLOT RESULTS
# ===============================================================================
#png("foresIII.png")
plot(forestry_exp_improved,
     main = "Improved Forestry Exposure - Watershed-based (Level III)",
     xlab = "Easting (UTM Zone 19N)", 
     ylab = "Northing (UTM Zone 19N)",
     axes = TRUE)

# Add scale bar
scalebar(d = 10000,  # distance in meters (adjust based on your map size)
         xy = NULL,   # NULL = bottom left corner
         type = "bar",
         divs = 2,
         below = "km",
         label = c(0, 5, 10))
#dev.off()

# Add river mouth sources
#points(river_mouth_sources_active, pch = 16, cex = 0.5, col = "black")

# Add watershed boundaries for context
#plot(st_geometry(watersheds), add = TRUE, border = "blue", lwd = 2)

#print("Improved forestry analysis complete!")
#print("Key improvements:")
#print("1. Forestry data cropped to individual watersheds")
#print("2. Impacts aggregated per watershed")
#print("3. Sources placed at river mouths (hydrologically accurate)")
#print("4. Exposure calculated from river discharge points")

```
# Summary
This forestry exposure analysis successfully developed a watershed-based model to quantify terrestrial forestry impacts on the Saguenay Fjord ecosystem. The methodology implemented several key innovations:

**Hydrologically-Accurate Approach**: River mouth sources were precisely located where terrestrial inputs enter the fjord, providing realistic transport pathways from watersheds to marine waters.

**Empirical Nitrogen Loading System**: The impact assessment utilizes peer-reviewed data from Palviainen et al. (2015) to estimate actual nitrogen export (kg N/year) from boreal forest watersheds, with impacts scaling non-linearly based on proportion of watershed logged (20-100%) and lasting 5 years post-harvest before returning to baseline conditions.

**Watershed-Scale Aggregation**: Forestry impacts were aggregated at the watershed scale rather than treating individual logging polygons in isolation, providing a more realistic assessment of cumulative effects.


# References

Amiro, B. D., A. G. Barr, T. A. Black, H. Iwashita, N. Kljun, J. H. McCaughey, K. Morgenstern, S. Murayama, Z. Nesic, A. L. Orchansky, and N. Saigusa. 2008. Carbon, energy and water fluxes at mature and disturbed forest sites, Saskatchewan, Canada. Agricultural and Forest Meteorology 136:237-251.
Axelrod, J. 2023. Canada's Boreal Clearcutting Is a Climate Threat. Natural Resources Defense Council.
Bouchon, É., and D. Arseneault. 2004. Fire disturbance during climate change: failure of postfire forest recovery on a boreal floodplain. Canadian Journal of Forest Research 34:2294-2305.
Garcia, E., R. Carignan, and J.-F. Lean. 2007. Seasonal and inter-annual variations in methyl mercury concentrations in zooplankton from boreal lakes impacted by deforestation or natural forest fires. Environmental Monitoring and Assessment 131:1-11.
Kreutzweiser, D. P., S. S. Capell, and K. P. Good. 2008. Logging impacts on the biogeochemistry of boreal forest soils and nutrient export to aquatic systems: A review. Canadian Journal of Forest Research 38:2223-2236.
Kuuluvainen, T., and T. Aakala. 2011. Natural forest dynamics in boreal Fennoscandia: a review and classification. Silva Fennica 45:823-841.
Lavoie, M., D. Paré, Y. Bergeron, E. Larouche, and A. Amiotte-Suchet. 2005. Soil organic carbon accumulation in black spruce stands of eastern Canada. Ecosystems 8:906-919.
Mackey, B., et al. 2024. Assessing the Cumulative Impacts of Forest Management on Forest Age Structure Development and Woodland Caribou Habitat in Boreal Landscapes: A Case Study from Two Canadian Provinces. Land 13:6.
Palviainen, M., Finér, L., Laurén, A., Mattsson, T., & Högbom, L. (2015). A method to estimate the impact of clear-cutting on nutrient concentrations in boreal headwater streams. *AMBIO*, 44(7), 521-535.
Porvari, P., M. Verta, J. Munthe, and M. Haapanen. 2003. Forestry practices increase mercury and methyl mercury output from boreal forest catchments. Environmental Science & Technology 37:2389-2393.
White, J. C., M. A. Wulder, T. Hermosilla, N. C. Coops, and G. W. Hobart. 2017. A nationwide annual characterization of 25 years of forest disturbance and recovery for Canada using Landsat time series. Remote Sensing of Environment 194:303-321.